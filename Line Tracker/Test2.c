#pragma config(Sensor, S1,     colorPort,           sensorCOLORFULL)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void displayRGBColorValues();
void displaySingleColorValue();
void displayPegCounts();

task buttonTask();

bool bDisplayPegCounts = false;


task main()
{
  //
  // Wait for Sensor to be connected.
  //
  nxtDisplayCenteredBigTextLine(0, "Color");
  nxtDisplayCenteredBigTextLine(2, "Sensor");
  nxtDisplayCenteredBigTextLine(4, "Test");

  StartTask(buttonTask);

  wait1Msec(200);  // Give sensor time to initialize

  nVolume = 2;
  while (true)
  {
	  //
    // Wait for the sensor to be initialized and connected. The sensor can take up to 250 milliseconds to
    // initialize.
    //
    // Re-initialization is required every time the sensor is changed to a different color sensor type
    //
    bool bFlashingState = true;

	  while (true)
	  {
	    if (validColorSensor(colorPort))
	      break;
	    if (bFlashingState)
	    {
	      nxtDisplayCenteredTextLine(6, "Connect Sensor");
		    nxtDisplayCenteredTextLine(7, "to Port S1");
		    PlaySound(soundBeepBeep);
		  }
	    else
	    {
	      nxtDisplayCenteredTextLine(6, "");
		    nxtDisplayCenteredTextLine(7, "");
		  }
	    bFlashingState = !bFlashingState;
	    wait1Msec(300);
		}

		//
    // Sensor is now connected.
    //
		PlaySound(soundFastUpwardTones);
    eraseDisplay();
    while (true)
		{
		  //
		  // Continuously loop. On every cycle of the loop display information on the current sensor state on the NXT LCD.
		  //
		  if (!validColorSensor(colorPort))
		    break;

		  if (bDisplayPegCounts)
		  {
		    displayPegCounts();
		  }
		  else
		  {
				nxtDisplayTextLine(2, "");
		    switch (SensorType[colorPort])
		    {
		    case sensorCOLORNONE:     nxtDisplayCenteredBigTextLine(0, "Ambient");    displaySingleColorValue();  break;
		    case sensorCOLORRED:      nxtDisplayCenteredBigTextLine(0, "Red");        displaySingleColorValue();  break;
		    case sensorCOLORGREEN:    nxtDisplayCenteredBigTextLine(0, "Green");      displaySingleColorValue();  break;
		    case sensorCOLORBLUE:     nxtDisplayCenteredBigTextLine(0, "Blue");       displaySingleColorValue();  break;
		    case sensorCOLORFULL:     nxtDisplayCenteredBigTextLine(0, "RGB");        displayRGBColorValues();    break;
		    default:                  nxtDisplayCenteredBigTextLine(0, "Bad Type");   break;
				}
			}
			wait1Msec(150);
		}

		// "validColorSensor" has failed. Either the sensor has been disconnected / transiently failed. Or the type of color
		// sensor has been changed by the "buttonTask".
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                              buttonTask
//
// A small task to switch between the various color sensor types using the left and right arrows.
//
// The "Enter" button is used to switch between displaying the sensor value and a display of diagnostic peg counts.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

task buttonTask()
{
  while (true)
  {
    wait1Msec(100);
    if (!validColorSensor(colorPort))
      continue;

    switch (nNxtButtonPressed)
    {
    case  kExitButton:
      StopAllTasks();
      break;


    case kEnterButton:
			//
			// Switch between sensor value display and diagnostic peg count mode
			//
			hogCPU();
			eraseDisplay();
			bDisplayPegCounts = !bDisplayPegCounts;
			releaseCPU();
			while (nNxtButtonPressed != kNoButton)
      {}
      break;

    case kRightButton:
			//
	    // "Increment" to the next valid color sensor type
	    //
	    switch (SensorType[colorPort])
	    {
	    case sensorCOLORNONE:     SensorType[colorPort] = sensorCOLORRED;         break;
	    case sensorCOLORRED:      SensorType[colorPort] = sensorCOLORGREEN;       break;
	    case sensorCOLORGREEN:    SensorType[colorPort] = sensorCOLORBLUE;        break;
	    case sensorCOLORBLUE:     SensorType[colorPort] = sensorCOLORFULL;        break;
	    default:
	    case sensorCOLORFULL:     SensorType[colorPort] = sensorCOLORNONE;        break;
			}
			while (nNxtButtonPressed != kNoButton)
      {}
      break;

    case kLeftButton:
			//
	    // "Decremet" to the previous valid color sensor type
	    //
			switch (SensorType[colorPort])
	    {
	    case sensorCOLORNONE:     SensorType[colorPort] = sensorCOLORFULL;       break;
	    case sensorCOLORRED:      SensorType[colorPort] = sensorCOLORNONE;       break;
	    case sensorCOLORGREEN:    SensorType[colorPort] = sensorCOLORRED;        break;
	    case sensorCOLORBLUE:     SensorType[colorPort] = sensorCOLORGREEN;      break;
	    default:
	    case sensorCOLORFULL:     SensorType[colorPort] = sensorCOLORBLUE;       break;
			}
			while (nNxtButtonPressed != kNoButton)
      {}
      break;
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                              displayColorIndex
//
// When in RGB mode, the sensor tries to dtect one of six reflected colors. This function displays the detected color
// on the NXT LCD.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void displayColorIndex()
{
  string sColor;

  switch (SensorValue[colorPort])
  {
  case BLACKCOLOR:    sColor = "Black";     break;
  case BLUECOLOR:     sColor = "Blue";      break;
  case GREENCOLOR:    sColor = "Green";     break;
  case YELLOWCOLOR:   sColor = "Yellow";    break;
  case REDCOLOR:      sColor = "Red";       break;
  case WHITECOLOR:    sColor = "White";     break;
  default:            sColor = "???";       break;
  }
  nxtDisplayCenteredTextLine(2, sColor);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                              displayRGBColorValues
//
// Displays all four possible color analog values on the NXT screen. The four values are:
//     Red          -- Analog value showing reflected light from Red   LED
//     Green        -- Analog value showing reflected light from Green LED
//     Blue         -- Analog value showing reflected light from Blue  LED
//     Ambient      -- No background LED turned on
//
// There are three numbers displayed for each color:
//     1. The raw analog value detected.
//     2. The "normalized" value detected. This is simply the raw value less the value of ambient light.
//     3. The "percentage" value detected. This is the "normalized" value scaled on a 0 to 100 (max value) scale.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displayRGBColorValues()
{
	short nAtoDValues[4];
	short nRawValues[4];
	short nColorValues[4];
	string sTemp;

  getColorSensorData(colorPort, colorAtoD,   &nAtoDValues[0]);
  getColorSensorData(colorPort, colorRaw,    &nRawValues[0]);
  getColorSensorData(colorPort, colorValue,  &nColorValues[0]);

  displayColorIndex();
  int t;
  if(nAtoDValues[0]<335){
  	t=0;
  }
  else if(nAtoDValues[0]>335){
  	t=1;
  }
  nxtDisplayTextLine(3, "   AtoD  Raw   %%");
  StringFormat(sTemp, "R  %4i%5i", nAtoDValues[0], t);
  if(nAtoDValues[1]<335){
  	t=0;
  }
  else if(nAtoDValues[1]>335){
  	t=1;
  }
  nxtDisplayTextLine(4, "%s", sTemp);
  StringFormat(sTemp, "G  %4i%5i", nAtoDValues[1], t);
  if(nAtoDValues[2]<335){
  	t=0;
  }
  else if(nAtoDValues[2]>335){
  	t=1;
  }
  nxtDisplayTextLine(5, "%s", sTemp);
  StringFormat(sTemp, "B  %4i%5i", nAtoDValues[2], t);
  if(nAtoDValues[3]<335){
  	t=0;
  }
  else if(nAtoDValues[3]>335){
  	t=1;
  }
  nxtDisplayTextLine(6, "%s", sTemp);
  StringFormat(sTemp, "Amb%4i%5i", nAtoDValues[3], t);
  nxtDisplayTextLine(7, "%s", sTemp, nColorValues[3]);
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                              displaySingleColorValue
//
// Displays the analog value of a single color on the NXT LCD screen
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displaySingleColorValue()
{
	word nAtoDValue;
	word nRawValue;
	word nColorValue;
	string sTemp;

	nAtoDValue    = 0;
	nRawValue     = SensorRaw[colorPort];
	nColorValue   = SensorValue[colorPort];

	nxtDisplayTextLine(3, "   AtoD  Raw   %%");
	switch (SensorType[colorPort])
  {
  case sensorCOLORRED:      StringFormat(sTemp, "R  %4i%5i", nAtoDValue, nRawValue);      nxtDisplayTextLine(4, "%s%4i", sTemp, nColorValue);  break;
  case sensorCOLORGREEN:    StringFormat(sTemp, "G  %4i%5i", nAtoDValue, nRawValue);      nxtDisplayTextLine(5, "%s%4i", sTemp, nColorValue);  break;
  case sensorCOLORBLUE:     StringFormat(sTemp, "B  %4i%5i", nAtoDValue, nRawValue);      nxtDisplayTextLine(6, "%s%4i", sTemp, nColorValue);  break;
  case sensorCOLORNONE:     StringFormat(sTemp, "Amb%4i%5i", nAtoDValue, nRawValue);      nxtDisplayTextLine(7, "%s%4i", sTemp, nColorValue);  break;
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                              displayPegCounts
//
// ROBOTC firmware keeps "peg counts" on various error conditions within the Color Sensor device driver. This is a
// function to display these error counts on the NXT's LCD screen.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void displayPegCounts()
{
  /*
	typedef struct
	{
		long nDisconnects;						// Incremented once when sensor detection (see nWaitForConnect) fails after sensor has
																	// been connected.
		long nSoftwareResets;         // Another pin on sensor indicates internal error condition. Incremented once per erro.
		long nCRCMismatch;            // 50 bytes are uploaded from sensor on startup. A CRC-code is used to detect errors.
																	// Peg count incremented once for each time failure is detected.
		long nWaitForConnect;					// Counts the number of times the sensor is not detected. There's an I/O pin on the
																	// sensor cable indicating whether sensor is working OK. This peg count is incremented
																	// every millisecond when not connected when it is supposed to be connected. Usually
																	// triggered by removing the sensor in mid-operation.
		long nReadCount;              // Not an error! A count of the number of times data is read from the sensor.
	} TColorPegCounts;
	*/

	TColorPegCounts nPegCounts;

  getColorSensorPegCounts(colorPort, &nPegCounts);

  nxtDisplayCenteredBigTextLine(0, "PegCounts");

	nxtDisplayTextLine(2, "%5d Reads",        nPegCounts.nReadCount);
	nxtDisplayTextLine(3, "");
	nxtDisplayTextLine(4, "%5d Disconnect",   nPegCounts.nDisconnects);
	nxtDisplayTextLine(5, "%5d Soft Reset",   nPegCounts.nSoftwareResets);
	nxtDisplayTextLine(6, "%5d CRC Errs:",    nPegCounts.nCRCMismatch);
	nxtDisplayTextLine(7, "%5d Wait 4 H/W",   nPegCounts.nWaitForConnect);
}
